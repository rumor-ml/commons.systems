name: Main/PR Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches: ['**']

# Only allow one pipeline per ref at a time
concurrency:
  group: push-main-${{ github.ref }}
  cancel-in-progress: true

env:
  GCP_PROJECT_ID: chalanding
  GCP_REGION: us-central1

permissions:
  contents: write
  id-token: write
  pull-requests: write
  issues: write
  actions: read

jobs:
  # ==================== Step 1: Local Tests (parallel per site) ====================
  local-tests:
    name: Local Tests - ${{ matrix.site }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      matrix:
        site: [fellspiral, videobrowser, audiobrowser]
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Cache node modules
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            */*/node_modules
          key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-

      - name: Install dependencies
        run: npm install

      - name: Test ${{ matrix.site }}
        run: ./infrastructure/scripts/run-local-tests.sh ${{ matrix.site }}

      - name: Test Print
        run: ./infrastructure/scripts/run-local-tests.sh print

  # ==================== Step 2: Deploy Sites (Parallel) ====================

  # Check if Playwright Server code changed
  check-playwright-changes:
    name: Check Playwright Changes
    runs-on: ubuntu-latest
    needs: local-tests
    outputs:
      changed: ${{ steps.filter.outputs.playwright }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for Playwright changes
        id: filter
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
          else
            # For pushes, compare with previous commit
            BASE_SHA="HEAD~1"
          fi

          if git diff --name-only $BASE_SHA HEAD | grep -q "^infrastructure/playwright-server/"; then
            echo "playwright=true" >> $GITHUB_OUTPUT
            echo "Playwright server code changed"
          else
            echo "playwright=false" >> $GITHUB_OUTPUT
            echo "No Playwright server changes detected"
          fi

  deploy-playwright:
    name: Deploy Playwright Server
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: check-playwright-changes
    if: needs.check-playwright-changes.outputs.changed == 'true'
    outputs:
      url: ${{ steps.playwright-url.outputs.url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

      - name: Deploy Playwright Server
        run: ./infrastructure/scripts/deploy-playwright-server.sh ${{ github.sha }}

      - name: Get Playwright Server URL
        id: playwright-url
        run: |
          URL=$(cat /tmp/playwright-server-url.txt)
          echo "url=${URL}" >> $GITHUB_OUTPUT
          echo "Playwright Server URL: ${URL}"

  initialize-rml-media:
    name: Initialize rml-media Firebase Storage
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: local-tests

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Initialize rml-media bucket
        continue-on-error: true
        run: |
          echo "Ensuring rml-media bucket is linked to Firebase Storage..."
          ACCESS_TOKEN=$(gcloud auth print-access-token)
          BUCKET_NAME="rml-media"

          # Try to link bucket to Firebase Storage (idempotent - safe to run multiple times)
          LINK_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{\"bucket\": \"projects/${{ env.GCP_PROJECT_ID }}/buckets/${BUCKET_NAME}\"}" \
            "https://firebasestorage.googleapis.com/v1beta/projects/${{ env.GCP_PROJECT_ID }}/buckets/${BUCKET_NAME}:addFirebase")

          if echo "$LINK_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            ERROR_STATUS=$(echo "$LINK_RESPONSE" | jq -r '.error.status // empty')
            if [ "$ERROR_STATUS" = "ALREADY_EXISTS" ] || echo "$LINK_RESPONSE" | grep -qi "already"; then
              echo "‚úì Bucket already linked to Firebase Storage"
            else
              echo "‚ö†Ô∏è  Could not link bucket (may already be linked or require manual setup)"
              echo "Response: $LINK_RESPONSE"
            fi
          else
            echo "‚úì Bucket successfully linked to Firebase Storage"
          fi

      - name: Configure CORS for rml-media bucket
        continue-on-error: true
        run: |
          echo "Configuring CORS for rml-media bucket..."
          ACCESS_TOKEN=$(gcloud auth print-access-token)
          BUCKET_NAME="rml-media"

          # Configure CORS to allow web access from any origin
          CORS_RESPONSE=$(curl -s -X PATCH \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            -d '{
              "cors": [
                {
                  "origin": ["*"],
                  "method": ["GET", "HEAD", "PUT", "POST", "DELETE"],
                  "responseHeader": ["Content-Type", "Authorization", "x-goog-resumable"],
                  "maxAgeSeconds": 3600
                }
              ]
            }' \
            "https://storage.googleapis.com/storage/v1/b/${BUCKET_NAME}")

          if echo "$CORS_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            echo "‚ö†Ô∏è  Could not configure CORS"
            echo "Response: $CORS_RESPONSE"
          else
            echo "‚úì CORS configured successfully"
          fi

      - name: Initialize rml-media bucket for Firebase Storage
        continue-on-error: true
        run: |
          echo "Initializing rml-media bucket for Firebase Storage..."
          ACCESS_TOKEN=$(gcloud auth print-access-token)
          BUCKET_NAME="rml-media"
          PROJECT_ID="${{ env.GCP_PROJECT_ID }}"

          # Link the GCS bucket to Firebase Storage
          # This is required for the Firebase SDK to access the bucket
          INIT_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{\"bucket\": \"projects/${PROJECT_ID}/buckets/${BUCKET_NAME}\"}" \
            "https://firebasestorage.googleapis.com/v1beta/projects/${PROJECT_ID}/buckets/${BUCKET_NAME}:addFirebase")

          if echo "$INIT_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            ERROR_CODE=$(echo "$INIT_RESPONSE" | jq -r '.error.code')
            if [ "$ERROR_CODE" = "409" ]; then
              echo "‚úì Bucket already initialized for Firebase Storage (expected)"
            else
              echo "‚ö†Ô∏è  Could not initialize bucket for Firebase Storage"
              echo "Response: $INIT_RESPONSE"
            fi
          else
            echo "‚úì Bucket successfully initialized for Firebase Storage"
          fi

      - name: Configure public access for rml-media bucket
        continue-on-error: true
        run: |
          echo "Configuring public access for rml-media bucket (shared by videobrowser and print)..."
          ACCESS_TOKEN=$(gcloud auth print-access-token)
          BUCKET_NAME="rml-media"

          # Non-default buckets can't use Firebase Storage security rules
          # Instead, we disable public access prevention and use IAM policies

          # Step 1: Disable public access prevention
          echo "Disabling public access prevention..."
          PAP_RESPONSE=$(curl -s -X PATCH \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            -d '{"iamConfiguration": {"publicAccessPrevention": "inherited"}}' \
            "https://storage.googleapis.com/storage/v1/b/${BUCKET_NAME}")

          if echo "$PAP_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            echo "‚ö†Ô∏è  Could not disable public access prevention"
            echo "Response: $PAP_RESPONSE"
          else
            echo "‚úì Public access prevention disabled (set to inherited)"
          fi

          # Step 2: Grant public read access via IAM
          echo "Granting public read access via IAM..."

          # Get current IAM policy
          IAM_POLICY=$(curl -s -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            "https://storage.googleapis.com/storage/v1/b/${BUCKET_NAME}/iam")

          # Add allUsers objectViewer binding if not already present
          UPDATED_POLICY=$(echo "$IAM_POLICY" | jq '
            .bindings |= (
              if any(.role == "roles/storage.objectViewer" and (.members // [] | contains(["allUsers"]))) then
                .
              else
                . + [{
                  "role": "roles/storage.objectViewer",
                  "members": ["allUsers"]
                }]
              end
            )
          ')

          IAM_RESPONSE=$(curl -s -X PUT \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "$UPDATED_POLICY" \
            "https://storage.googleapis.com/storage/v1/b/${BUCKET_NAME}/iam")

          if echo "$IAM_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            echo "‚ö†Ô∏è  Could not grant public read access"
            echo "Response: $IAM_RESPONSE"
          else
            echo "‚úì Public read access granted via IAM (allUsers can read objects)"
          fi

          echo "‚úì rml-media bucket configured for public read access"

  deploy-sites:
    name: Deploy ${{ matrix.site }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [local-tests, initialize-rml-media]
    strategy:
      matrix:
        site: [fellspiral, videobrowser, audiobrowser, print]
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Cache node modules
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            */*/node_modules
          key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-

      - name: Install dependencies
        run: npm install

      - name: Install dependencies (jq)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Cache Firebase CLI
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-firebase-cli
          restore-keys: |
            ${{ runner.os }}-firebase-cli

      - name: Install Firebase CLI
        run: npm install -g firebase-tools

      # Note: Firebase configuration is injected by deploy-firebase-hosting.sh script

      # ========== Deploy Firestore Rules (Fellspiral only) ==========
      - name: Deploy Firestore rules
        if: matrix.site == 'fellspiral'
        run: |
          set -e
          echo "Deploying Firestore rules..."
          ACCESS_TOKEN=$(gcloud auth print-access-token)
          RULES_CONTENT=$(cat fellspiral/firestore.rules | jq -Rs '.')

          RULESET_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -H "x-goog-user-project: ${{ env.GCP_PROJECT_ID }}" \
            -H "Content-Type: application/json" \
            -d "{\"source\": {\"files\": [{\"name\": \"firestore.rules\", \"content\": ${RULES_CONTENT}}]}}" \
            "https://firebaserules.googleapis.com/v1/projects/${{ env.GCP_PROJECT_ID }}/rulesets")

          if echo "$RULESET_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            echo "‚ùå Failed to create ruleset"
            exit 1
          fi

          RULESET_NAME=$(echo "$RULESET_RESPONSE" | jq -r '.name // empty')
          echo "‚úì Created ruleset: $RULESET_NAME"

          RELEASE_RESPONSE=$(curl -s -X PATCH \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -H "x-goog-user-project: ${{ env.GCP_PROJECT_ID }}" \
            -H "Content-Type: application/json" \
            -d "{\"release\": {\"name\": \"projects/${{ env.GCP_PROJECT_ID }}/releases/cloud.firestore\", \"rulesetName\": \"${RULESET_NAME}\"}}" \
            "https://firebaserules.googleapis.com/v1/projects/${{ env.GCP_PROJECT_ID }}/releases/cloud.firestore")

          if echo "$RELEASE_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            echo "‚ö†Ô∏è  Failed to release ruleset"
          else
            echo "‚úì Firestore rules deployed"
          fi

      # Note: rml-media bucket initialization and rules deployment now handled by initialize-rml-media job

      # ========== Deploy Site ==========
      - name: Deploy ${{ matrix.site }} to Firebase Hosting
        run: ./infrastructure/scripts/deploy-firebase-hosting.sh ${{ matrix.site }} ${{ github.ref_name }} ${{ github.sha }}

      - name: Get deployment URL
        id: site-url
        run: |
          URL=$(cat /tmp/deployment-url.txt)
          echo "url=${URL}" >> $GITHUB_OUTPUT
          echo "${{ matrix.site }} URL: ${URL}"

      - name: Upload deployment URL as artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-url-${{ matrix.site }}
          path: /tmp/deployment-url.txt
          retention-days: 1

  # ==================== Collect Deployment URLs ====================
  collect-urls:
    name: Collect Deployment URLs
    runs-on: ubuntu-latest
    needs: deploy-sites
    outputs:
      fellspiral-url: ${{ steps.get-urls.outputs.fellspiral-url }}
      videobrowser-url: ${{ steps.get-urls.outputs.videobrowser-url }}
      audiobrowser-url: ${{ steps.get-urls.outputs.audiobrowser-url }}
      print-url: ${{ steps.get-urls.outputs.print-url }}

    steps:
      - name: Download deployment URL artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: deployment-url-*
          merge-multiple: false

      - name: Get deployment URLs from artifacts
        id: get-urls
        run: |
          # Read URLs from artifacts created by deploy jobs
          FELLSPIRAL_URL=$(cat deployment-url-fellspiral/deployment-url.txt)
          VIDEOBROWSER_URL=$(cat deployment-url-videobrowser/deployment-url.txt)
          AUDIOBROWSER_URL=$(cat deployment-url-audiobrowser/deployment-url.txt)
          PRINT_URL=$(cat deployment-url-print/deployment-url.txt)

          echo "fellspiral-url=${FELLSPIRAL_URL}" >> $GITHUB_OUTPUT
          echo "videobrowser-url=${VIDEOBROWSER_URL}" >> $GITHUB_OUTPUT
          echo "audiobrowser-url=${AUDIOBROWSER_URL}" >> $GITHUB_OUTPUT
          echo "print-url=${PRINT_URL}" >> $GITHUB_OUTPUT

          echo "Fellspiral URL: ${FELLSPIRAL_URL}"
          echo "Videobrowser URL: ${VIDEOBROWSER_URL}"
          echo "Audiobrowser URL: ${AUDIOBROWSER_URL}"
          echo "Print URL: ${PRINT_URL}"

  # ==================== Step 3: Get Playwright Server URL ====================
  get-playwright-url:
    name: Get Playwright Server URL
    runs-on: ubuntu-latest
    needs: [check-playwright-changes, deploy-playwright]
    if: always()
    outputs:
      url: ${{ steps.get-url.outputs.url }}

    steps:
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Get Playwright Server URL
        id: get-url
        run: |
          if [ "${{ needs.check-playwright-changes.outputs.changed }}" == "true" ]; then
            # Use newly deployed URL
            URL="${{ needs.deploy-playwright.outputs.url }}"
          else
            # Get existing service URL
            URL=$(gcloud run services describe playwright-server \
              --region=${{ env.GCP_REGION }} \
              --project=${{ env.GCP_PROJECT_ID }} \
              --format='value(status.url)')
          fi
          echo "url=${URL}" >> $GITHUB_OUTPUT
          echo "Playwright Server URL: ${URL}"

  # ==================== Step 4: E2E Tests (parallel per site) ====================
  e2e-tests:
    name: E2E Tests - ${{ matrix.site }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [collect-urls, get-playwright-url]
    strategy:
      matrix:
        site: [fellspiral, videobrowser, audiobrowser, print]
      fail-fast: false
    if: |
      always() &&
      needs.collect-urls.result == 'success' &&
      needs.get-playwright-url.result == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Cache node modules
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            */*/node_modules
          key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-

      - name: Install dependencies
        run: npm install

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Get site URL
        id: site-url
        run: |
          case "${{ matrix.site }}" in
            fellspiral)
              echo "url=${{ needs.collect-urls.outputs.fellspiral-url }}" >> $GITHUB_OUTPUT
              ;;
            videobrowser)
              echo "url=${{ needs.collect-urls.outputs.videobrowser-url }}" >> $GITHUB_OUTPUT
              ;;
            audiobrowser)
              echo "url=${{ needs.collect-urls.outputs.audiobrowser-url }}" >> $GITHUB_OUTPUT
              ;;
            print)
              echo "url=${{ needs.collect-urls.outputs.print-url }}" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Test ${{ matrix.site }}
        run: ./infrastructure/scripts/run-playwright-tests.sh ${{ matrix.site }} "${{ steps.site-url.outputs.url }}" "${{ needs.get-playwright-url.outputs.url }}"
        env:
          PLAYWRIGHT_SERVER_URL: ${{ needs.get-playwright-url.outputs.url }}
          DEPLOYED_URL: ${{ steps.site-url.outputs.url }}
          CI: true

  # ==================== Rollback on failure (main branch only) ====================
  rollback-on-failure:
    name: Rollback on Test Failure
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [deploy-sites, e2e-tests]
    if: |
      always() &&
      github.ref == 'refs/heads/main' &&
      needs.deploy-sites.result == 'success' &&
      contains(needs.e2e-tests.result, 'failure')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Note about Firebase Hosting rollback
        run: |
          echo "‚ö†Ô∏è  Firebase Hosting deployments don't support automatic rollback"
          echo "üìù To manually rollback, use: firebase hosting:rollback <site-id>"
          echo "üîç Sites: fellspiral, videobrowser-7696a, audiobrowser, print-dfb47"
          echo ""
          echo "Previous deployments are still available in Firebase Hosting history"

      - name: Create rollback issue
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'üö® Automatic Rollback: All Sites',
              body: `E2E tests failed after deployment to main branch.\n\nCommit: ${context.sha}\n\nWorkflow: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              labels: ['bug', 'deployment', 'rollback']
            })

  # ==================== Merge Check (Required Status Check) ====================
  merge-check:
    name: Merge Check - All Tests Passed
    runs-on: ubuntu-latest
    needs: [local-tests, deploy-sites, e2e-tests]
    if: always()

    steps:
      - name: Check all jobs succeeded
        run: |
          echo "Checking job results..."
          echo "Local Tests: ${{ needs.local-tests.result }}"
          echo "Deploy Sites: ${{ needs.deploy-sites.result }}"
          echo "E2E Tests: ${{ needs.e2e-tests.result }}"

          # All jobs must succeed for merge check to pass
          if [ "${{ needs.local-tests.result }}" != "success" ]; then
            echo "‚ùå Local tests failed or were skipped"
            exit 1
          fi

          if [ "${{ needs.deploy-sites.result }}" != "success" ]; then
            echo "‚ùå Site deployments failed or were skipped"
            exit 1
          fi

          if [ "${{ needs.e2e-tests.result }}" != "success" ]; then
            echo "‚ùå E2E tests failed or were skipped"
            exit 1
          fi

          echo "‚úÖ All required jobs succeeded - merge check passed!"
