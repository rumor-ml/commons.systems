name: Main/PR Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches: ['**']
  merge_group:
  workflow_dispatch:

# Only allow one pipeline per ref at a time
concurrency:
  group: push-main-${{ github.ref }}
  cancel-in-progress: true

env:
  GCP_PROJECT_ID: chalanding
  GCP_REGION: us-central1

permissions:
  contents: write
  id-token: write
  pull-requests: write
  issues: write
  actions: write
  packages: read
  deployments: write

jobs:
  # ==================== Check CI Image Availability ====================
  check-ci-image:
    name: Check CI Image
    runs-on: ubuntu-latest
    outputs:
      exists: ${{ steps.check.outputs.exists }}
    steps:
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if CI image exists
        id: check
        run: |
          if docker manifest inspect ghcr.io/${{ github.repository }}/ci-base:latest > /dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "CI image exists, will use container"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "CI image not found, will use fallback"
          fi

  # ==================== Step 1: Discover Apps ====================
  # ==================== Firebase App Tests ====================
  test-firebase-fellspiral:
    name: Test Firebase - fellspiral
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup-node-pnpm
        with:
          install-playwright: 'true'
          install-firebase: 'true'
      - name: Run tests
        run: ./test --module=fellspiral --type=e2e --ci

  test-firebase-videobrowser:
    name: Test Firebase - videobrowser
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup-node-pnpm
        with:
          install-playwright: 'true'
          install-firebase: 'true'
      - name: Run tests
        run: ./test --module=videobrowser --type=e2e --ci

  test-firebase-audiobrowser:
    name: Test Firebase - audiobrowser
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup-node-pnpm
        with:
          install-playwright: 'true'
          install-firebase: 'true'
      - name: Run tests
        run: ./test --module=audiobrowser --type=e2e --ci

  test-firebase-print:
    name: Test Firebase - print
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup-node-pnpm
        with:
          install-playwright: 'true'
          install-firebase: 'true'
      - name: Run tests
        run: ./test --module=print --type=e2e --ci

  # ==================== Go TUI App Tests ====================
  test-go-tui-tmux-tui:
    name: Test Go TUI - tmux-tui
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.22'
      - name: Run tests
        run: ./test --module=tmux-tui --type=e2e --ci

  # ==================== Go Fullstack App Tests ====================
  test-go-fullstack-printsync:
    name: Test Go Fullstack - printsync
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - uses: ./.github/actions/setup-gcp-auth
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - uses: ./.github/actions/setup-node-pnpm
        with:
          install-playwright: 'true'
          install-firebase: 'true'

      - name: Install system dependencies
        run: sudo apt-get update && sudo apt-get install -y make

      - name: Install templ
        run: go install github.com/a-h/templ/cmd/templ@latest

      - name: Run tests
        run: ./test --module=printsync --type=e2e --ci

      - name: Upload emulator logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: emulator-logs-printsync
          path: /tmp/claude/emulators.log
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload test results on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-printsync
          path: |
            printsync/test-results/
            printsync/playwright-report/
          retention-days: 7
          if-no-files-found: ignore

  # ==================== Go Package Tests ====================
  test-go-packages-filesync:
    name: Test Go Pkg - filesync
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.22'
      - name: Run tests
        run: ./test --module=filesync --type=unit --ci

  # ==================== Deploy Firestore Rules ====================
  deploy-firestore-rules:
    name: Deploy Firestore Rules
    runs-on: ubuntu-latest
    needs: [test-firebase-fellspiral]
    if: needs.test-firebase-fellspiral.result == 'success'
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Install dependencies (jq)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Deploy Firestore rules
        run: |
          set -e
          echo "Deploying Firestore rules..."
          ACCESS_TOKEN=$(gcloud auth print-access-token)
          RULES_CONTENT=$(cat fellspiral/firestore.rules | jq -Rs '.')

          RULESET_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -H "x-goog-user-project: ${{ env.GCP_PROJECT_ID }}" \
            -H "Content-Type: application/json" \
            -d "{\"source\": {\"files\": [{\"name\": \"firestore.rules\", \"content\": ${RULES_CONTENT}}]}}" \
            "https://firebaserules.googleapis.com/v1/projects/${{ env.GCP_PROJECT_ID }}/rulesets")

          if echo "$RULESET_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            echo "‚ùå Failed to create ruleset"
            exit 1
          fi

          RULESET_NAME=$(echo "$RULESET_RESPONSE" | jq -r '.name // empty')
          echo "‚úì Created ruleset: $RULESET_NAME"

          RELEASE_RESPONSE=$(curl -s -X PATCH \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -H "x-goog-user-project: ${{ env.GCP_PROJECT_ID }}" \
            -H "Content-Type: application/json" \
            -d "{\"release\": {\"name\": \"projects/${{ env.GCP_PROJECT_ID }}/releases/cloud.firestore\", \"rulesetName\": \"${RULESET_NAME}\"}}" \
            "https://firebaserules.googleapis.com/v1/projects/${{ env.GCP_PROJECT_ID }}/releases/cloud.firestore")

          if echo "$RELEASE_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            echo "‚ùå CRITICAL: Failed to release Firestore ruleset"
            echo "Error details:"
            echo "$RELEASE_RESPONSE" | jq '.error'
            exit 1
          fi

          RELEASE_NAME=$(echo "$RELEASE_RESPONSE" | jq -r '.name // empty')
          if [ -z "$RELEASE_NAME" ]; then
            echo "‚ùå CRITICAL: Firestore rules release missing 'name' field"
            exit 1
          fi

          echo "‚úì Firestore rules deployed: $RELEASE_NAME"

  # ==================== Step 2: Deploy Sites (Parallel) ====================
  deploy-fellspiral:
    name: Deploy fellspiral
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [test-firebase-fellspiral]
    if: needs.test-firebase-fellspiral.result == 'success'
    outputs:
      url: ${{ steps.site-url.outputs.url }}

    steps:
      - uses: actions/checkout@v4

      - uses: ./.github/actions/setup-node-pnpm
        with:
          install-playwright: 'false'

      - uses: ./.github/actions/setup-gcp-firebase
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Sanitize branch name for environment
        if: github.event_name == 'pull_request'
        id: sanitize
        uses: ./.github/actions/sanitize-branch-name
        with:
          branch_name: ${{ github.head_ref }}

      - name: Create GitHub deployment
        id: create-deployment
        uses: ./.github/actions/create-deployment
        with:
          environment_url: ${{ github.event_name == 'pull_request' && format('https://preview-{0}-fellspiral.web.app', steps.sanitize.outputs.sanitized) || 'https://fellspiral.web.app' }}
          site_name: 'fellspiral'
          branch_name: ${{ github.event_name == 'pull_request' && github.head_ref || 'main' }}

      - name: Inject environment variables for build
        working-directory: fellspiral
        run: |
          # Create .env file for Vite (in site/ directory where Vite command runs)
          echo "VITE_PR_NUMBER=${{ github.event.pull_request.number }}" > site/.env
          echo "VITE_BRANCH_NAME=${{ github.head_ref || github.ref_name }}" >> site/.env

          # Show what we're building
          if [ -n "${{ github.event.pull_request.number }}" ]; then
            echo "Building for PR #${{ github.event.pull_request.number }}"
            echo "Collection will be: cards_pr_${{ github.event.pull_request.number }}"
          else
            echo "Building for branch: ${{ github.ref_name }}"
          fi

      - name: Deploy fellspiral to Firebase Hosting
        id: deploy
        continue-on-error: true
        run: ./infrastructure/scripts/deploy-firebase-hosting.sh fellspiral ${{ github.event_name == 'pull_request' && github.head_ref || github.ref_name }} ${{ github.sha }}

      - name: Get deployment URL
        id: site-url
        uses: ./.github/actions/validate-deployment-url

      - name: Trigger retry workflow on new worker if deployment failed
        id: retry
        if: steps.deploy.outcome == 'failure'
        env:
          GH_TOKEN: ${{ github.token }}
          DEPLOYMENT_URL: ${{ steps.site-url.outputs.url }}
          RUN_ID: ${{ github.run_id }}
        run: |
          echo "‚ö†Ô∏è  Deployment health check failed. Triggering retry on new worker..."

          gh workflow run retry-health-check.yml \
            -f deployment_url="${DEPLOYMENT_URL}" \
            -f site_name="fellspiral" \
            -f original_run_id="${RUN_ID}" \
            -f original_job_name="deploy-fellspiral"

          sleep 5
          RETRY_RUN_ID=$(gh run list --workflow=retry-health-check.yml --limit 1 --json databaseId --jq '.[0].databaseId')
          echo "Retry workflow started: Run ID ${RETRY_RUN_ID}"

          echo "Waiting for retry workflow to complete..."
          gh run watch "${RETRY_RUN_ID}" --exit-status

          echo "‚úÖ Health check passed on new worker - original deployment was successful"

      - name: Check final deployment status
        if: always()
        run: |
          if [ "${{ steps.deploy.outcome }}" == "success" ]; then
            echo "‚úÖ Deployment succeeded on first attempt"
            exit 0
          elif [ "${{ steps.retry.outcome }}" == "success" ]; then
            echo "‚úÖ Deployment succeeded on retry (new worker)"
            exit 0
          else
            echo "‚ùå Deployment failed on both original and retry attempts"
            exit 1
          fi

      - name: Update deployment status to success
        if: success()
        uses: ./.github/actions/update-deployment-status
        with:
          deployment_id: ${{ steps.create-deployment.outputs.deployment_id }}
          state: 'success'
          environment_url: ${{ steps.site-url.outputs.url }}
          description: 'Deployment successful and verified'

      - name: Update deployment status to failure
        if: failure() && steps.create-deployment.outputs.deployment_id != ''
        uses: ./.github/actions/update-deployment-status
        with:
          deployment_id: ${{ steps.create-deployment.outputs.deployment_id }}
          state: 'failure'
          environment_url: ${{ steps.site-url.outputs.url }}
          description: 'Deployment failed'

  seed-firestore-fellspiral:
    name: Seed Firestore - fellspiral
    runs-on: ubuntu-latest
    needs: [deploy-fellspiral, deploy-firestore-rules]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: |
          # Install firebase-admin in temp directory to avoid workspace protocol issues
          mkdir -p /tmp/seed-deps
          cd /tmp/seed-deps
          npm install firebase-admin

          # Copy all dependencies to fellspiral/node_modules for ES module resolution
          mkdir -p $GITHUB_WORKSPACE/fellspiral/node_modules
          cp -r /tmp/seed-deps/node_modules/* $GITHUB_WORKSPACE/fellspiral/node_modules/

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Seed Firestore with namespaced collection
        working-directory: fellspiral
        env:
          FIRESTORE_PROJECT_ID: chalanding
          PR_NUMBER: ${{ github.event.pull_request.number }}
          BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
        run: |
          # Show which collection we're seeding
          if [ -n "$PR_NUMBER" ]; then
            echo "Seeding collection: cards_pr_$PR_NUMBER"
          elif [ "$BRANCH_NAME" != "main" ]; then
            echo "Seeding collection: cards_preview_$BRANCH_NAME"
          else
            echo "Seeding collection: cards (production)"
          fi

          node scripts/seed-firestore.js

  deploy-videobrowser:
    name: Deploy videobrowser
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [test-firebase-videobrowser]
    if: needs.test-firebase-videobrowser.result == 'success'
    outputs:
      url: ${{ steps.site-url.outputs.url }}

    steps:
      - uses: actions/checkout@v4

      - uses: ./.github/actions/setup-node-pnpm
        with:
          install-playwright: 'false'

      - uses: ./.github/actions/setup-gcp-firebase
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Sanitize branch name for environment
        if: github.event_name == 'pull_request'
        id: sanitize
        uses: ./.github/actions/sanitize-branch-name
        with:
          branch_name: ${{ github.head_ref }}

      - name: Create GitHub deployment
        id: create-deployment
        uses: ./.github/actions/create-deployment
        with:
          environment_url: ${{ github.event_name == 'pull_request' && format('https://preview-{0}-videobrowser.web.app', steps.sanitize.outputs.sanitized) || 'https://videobrowser.web.app' }}
          site_name: 'videobrowser'
          branch_name: ${{ github.event_name == 'pull_request' && github.head_ref || 'main' }}

      - name: Deploy videobrowser to Firebase Hosting
        id: deploy
        continue-on-error: true
        run: ./infrastructure/scripts/deploy-firebase-hosting.sh videobrowser ${{ github.event_name == 'pull_request' && github.head_ref || github.ref_name }} ${{ github.sha }}

      - name: Get deployment URL
        id: site-url
        uses: ./.github/actions/validate-deployment-url

      - name: Trigger retry workflow on new worker if deployment failed
        id: retry
        if: steps.deploy.outcome == 'failure'
        env:
          GH_TOKEN: ${{ github.token }}
          DEPLOYMENT_URL: ${{ steps.site-url.outputs.url }}
          RUN_ID: ${{ github.run_id }}
        run: |
          echo "‚ö†Ô∏è  Deployment health check failed. Triggering retry on new worker..."

          gh workflow run retry-health-check.yml \
            -f deployment_url="${DEPLOYMENT_URL}" \
            -f site_name="videobrowser" \
            -f original_run_id="${RUN_ID}" \
            -f original_job_name="deploy-videobrowser"

          sleep 5
          RETRY_RUN_ID=$(gh run list --workflow=retry-health-check.yml --limit 1 --json databaseId --jq '.[0].databaseId')
          echo "Retry workflow started: Run ID ${RETRY_RUN_ID}"

          echo "Waiting for retry workflow to complete..."
          gh run watch "${RETRY_RUN_ID}" --exit-status

          echo "‚úÖ Health check passed on new worker - original deployment was successful"

      - name: Check final deployment status
        if: always()
        run: |
          if [ "${{ steps.deploy.outcome }}" == "success" ]; then
            echo "‚úÖ Deployment succeeded on first attempt"
            exit 0
          elif [ "${{ steps.retry.outcome }}" == "success" ]; then
            echo "‚úÖ Deployment succeeded on retry (new worker)"
            exit 0
          else
            echo "‚ùå Deployment failed on both original and retry attempts"
            exit 1
          fi

      - name: Update deployment status to success
        if: success()
        uses: ./.github/actions/update-deployment-status
        with:
          deployment_id: ${{ steps.create-deployment.outputs.deployment_id }}
          state: 'success'
          environment_url: ${{ steps.site-url.outputs.url }}
          description: 'Deployment successful and verified'

      - name: Update deployment status to failure
        if: failure() && steps.create-deployment.outputs.deployment_id != ''
        uses: ./.github/actions/update-deployment-status
        with:
          deployment_id: ${{ steps.create-deployment.outputs.deployment_id }}
          state: 'failure'
          environment_url: ${{ steps.site-url.outputs.url }}
          description: 'Deployment failed'

  deploy-audiobrowser:
    name: Deploy audiobrowser
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [test-firebase-audiobrowser]
    if: needs.test-firebase-audiobrowser.result == 'success'
    outputs:
      url: ${{ steps.site-url.outputs.url }}

    steps:
      - uses: actions/checkout@v4

      - uses: ./.github/actions/setup-node-pnpm
        with:
          install-playwright: 'false'

      - uses: ./.github/actions/setup-gcp-firebase
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Sanitize branch name for environment
        if: github.event_name == 'pull_request'
        id: sanitize
        uses: ./.github/actions/sanitize-branch-name
        with:
          branch_name: ${{ github.head_ref }}

      - name: Create GitHub deployment
        id: create-deployment
        uses: ./.github/actions/create-deployment
        with:
          environment_url: ${{ github.event_name == 'pull_request' && format('https://preview-{0}-audiobrowser.web.app', steps.sanitize.outputs.sanitized) || 'https://audiobrowser.web.app' }}
          site_name: 'audiobrowser'
          branch_name: ${{ github.event_name == 'pull_request' && github.head_ref || 'main' }}

      - name: Deploy audiobrowser to Firebase Hosting
        id: deploy
        continue-on-error: true
        run: ./infrastructure/scripts/deploy-firebase-hosting.sh audiobrowser ${{ github.event_name == 'pull_request' && github.head_ref || github.ref_name }} ${{ github.sha }}

      - name: Get deployment URL
        id: site-url
        uses: ./.github/actions/validate-deployment-url

      - name: Trigger retry workflow on new worker if deployment failed
        id: retry
        if: steps.deploy.outcome == 'failure'
        env:
          GH_TOKEN: ${{ github.token }}
          DEPLOYMENT_URL: ${{ steps.site-url.outputs.url }}
          RUN_ID: ${{ github.run_id }}
        run: |
          echo "‚ö†Ô∏è  Deployment health check failed. Triggering retry on new worker..."

          gh workflow run retry-health-check.yml \
            -f deployment_url="${DEPLOYMENT_URL}" \
            -f site_name="audiobrowser" \
            -f original_run_id="${RUN_ID}" \
            -f original_job_name="deploy-audiobrowser"

          sleep 5
          RETRY_RUN_ID=$(gh run list --workflow=retry-health-check.yml --limit 1 --json databaseId --jq '.[0].databaseId')
          echo "Retry workflow started: Run ID ${RETRY_RUN_ID}"

          echo "Waiting for retry workflow to complete..."
          gh run watch "${RETRY_RUN_ID}" --exit-status

          echo "‚úÖ Health check passed on new worker - original deployment was successful"

      - name: Check final deployment status
        if: always()
        run: |
          if [ "${{ steps.deploy.outcome }}" == "success" ]; then
            echo "‚úÖ Deployment succeeded on first attempt"
            exit 0
          elif [ "${{ steps.retry.outcome }}" == "success" ]; then
            echo "‚úÖ Deployment succeeded on retry (new worker)"
            exit 0
          else
            echo "‚ùå Deployment failed on both original and retry attempts"
            exit 1
          fi

      - name: Update deployment status to success
        if: success()
        uses: ./.github/actions/update-deployment-status
        with:
          deployment_id: ${{ steps.create-deployment.outputs.deployment_id }}
          state: 'success'
          environment_url: ${{ steps.site-url.outputs.url }}
          description: 'Deployment successful and verified'

      - name: Update deployment status to failure
        if: failure() && steps.create-deployment.outputs.deployment_id != ''
        uses: ./.github/actions/update-deployment-status
        with:
          deployment_id: ${{ steps.create-deployment.outputs.deployment_id }}
          state: 'failure'
          environment_url: ${{ steps.site-url.outputs.url }}
          description: 'Deployment failed'

  deploy-print:
    name: Deploy print
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [test-firebase-print]
    if: needs.test-firebase-print.result == 'success'
    outputs:
      url: ${{ steps.site-url.outputs.url }}

    steps:
      - uses: actions/checkout@v4

      - uses: ./.github/actions/setup-node-pnpm
        with:
          install-playwright: 'false'

      - uses: ./.github/actions/setup-gcp-firebase
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Sanitize branch name for environment
        if: github.event_name == 'pull_request'
        id: sanitize
        uses: ./.github/actions/sanitize-branch-name
        with:
          branch_name: ${{ github.head_ref }}

      - name: Create GitHub deployment
        id: create-deployment
        uses: ./.github/actions/create-deployment
        with:
          environment_url: ${{ github.event_name == 'pull_request' && format('https://preview-{0}-print.web.app', steps.sanitize.outputs.sanitized) || 'https://print.web.app' }}
          site_name: 'print'
          branch_name: ${{ github.event_name == 'pull_request' && github.head_ref || 'main' }}

      - name: Deploy print to Firebase Hosting
        id: deploy
        continue-on-error: true
        run: ./infrastructure/scripts/deploy-firebase-hosting.sh print ${{ github.event_name == 'pull_request' && github.head_ref || github.ref_name }} ${{ github.sha }}

      - name: Get deployment URL
        id: site-url
        uses: ./.github/actions/validate-deployment-url

      - name: Trigger retry workflow on new worker if deployment failed
        id: retry
        if: steps.deploy.outcome == 'failure'
        env:
          GH_TOKEN: ${{ github.token }}
          DEPLOYMENT_URL: ${{ steps.site-url.outputs.url }}
          RUN_ID: ${{ github.run_id }}
        run: |
          echo "‚ö†Ô∏è  Deployment health check failed. Triggering retry on new worker..."

          gh workflow run retry-health-check.yml \
            -f deployment_url="${DEPLOYMENT_URL}" \
            -f site_name="print" \
            -f original_run_id="${RUN_ID}" \
            -f original_job_name="deploy-print"

          sleep 5
          RETRY_RUN_ID=$(gh run list --workflow=retry-health-check.yml --limit 1 --json databaseId --jq '.[0].databaseId')
          echo "Retry workflow started: Run ID ${RETRY_RUN_ID}"

          echo "Waiting for retry workflow to complete..."
          gh run watch "${RETRY_RUN_ID}" --exit-status

          echo "‚úÖ Health check passed on new worker - original deployment was successful"

      - name: Check final deployment status
        if: always()
        run: |
          if [ "${{ steps.deploy.outcome }}" == "success" ]; then
            echo "‚úÖ Deployment succeeded on first attempt"
            exit 0
          elif [ "${{ steps.retry.outcome }}" == "success" ]; then
            echo "‚úÖ Deployment succeeded on retry (new worker)"
            exit 0
          else
            echo "‚ùå Deployment failed on both original and retry attempts"
            exit 1
          fi

      - name: Update deployment status to success
        if: success()
        uses: ./.github/actions/update-deployment-status
        with:
          deployment_id: ${{ steps.create-deployment.outputs.deployment_id }}
          state: 'success'
          environment_url: ${{ steps.site-url.outputs.url }}
          description: 'Deployment successful and verified'

      - name: Update deployment status to failure
        if: failure() && steps.create-deployment.outputs.deployment_id != ''
        uses: ./.github/actions/update-deployment-status
        with:
          deployment_id: ${{ steps.create-deployment.outputs.deployment_id }}
          state: 'failure'
          environment_url: ${{ steps.site-url.outputs.url }}
          description: 'Deployment failed'

  # ==================== Step 3: E2E Tests (parallel per site) ====================
  e2e-fellspiral:
    name: E2E Tests - fellspiral
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [deploy-fellspiral, seed-firestore-fellspiral]
    if: needs.seed-firestore-fellspiral.result == 'success'

    steps:
      - uses: actions/checkout@v4

      - uses: ./.github/actions/setup-node-pnpm
        with:
          install-playwright: 'true'

      - uses: ./.github/actions/setup-gcp-auth
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Test fellspiral
        run: ./test --module=fellspiral --type=deployed-e2e --ci
        env:
          DEPLOYED_URL: ${{ needs.deploy-fellspiral.outputs.url }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          BRANCH_NAME: ${{ github.head_ref || github.ref_name }}

  e2e-videobrowser:
    name: E2E Tests - videobrowser
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [deploy-videobrowser]

    steps:
      - uses: actions/checkout@v4

      - uses: ./.github/actions/setup-node-pnpm
        with:
          install-playwright: 'true'

      - uses: ./.github/actions/setup-gcp-auth
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Test videobrowser
        run: ./test --module=videobrowser --type=deployed-e2e --ci
        env:
          DEPLOYED_URL: ${{ needs.deploy-videobrowser.outputs.url }}

  e2e-audiobrowser:
    name: E2E Tests - audiobrowser
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [deploy-audiobrowser]

    steps:
      - uses: actions/checkout@v4

      - uses: ./.github/actions/setup-node-pnpm
        with:
          install-playwright: 'true'

      - uses: ./.github/actions/setup-gcp-auth
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Test audiobrowser
        run: ./test --module=audiobrowser --type=deployed-e2e --ci
        env:
          DEPLOYED_URL: ${{ needs.deploy-audiobrowser.outputs.url }}

  e2e-print:
    name: E2E Tests - print
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [deploy-print]

    steps:
      - uses: actions/checkout@v4

      - uses: ./.github/actions/setup-node-pnpm
        with:
          install-playwright: 'true'

      - uses: ./.github/actions/setup-gcp-auth
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Test print
        run: ./test --module=print --type=deployed-e2e --ci
        env:
          DEPLOYED_URL: ${{ needs.deploy-print.outputs.url }}

  # ==================== Rollback on failure (main branch only) ====================
  rollback-on-failure:
    name: Rollback on Test Failure
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs:
      [
        deploy-fellspiral,
        deploy-videobrowser,
        deploy-audiobrowser,
        deploy-print,
        e2e-fellspiral,
        e2e-videobrowser,
        e2e-audiobrowser,
        e2e-print,
      ]
    if: |
      always() &&
      github.ref == 'refs/heads/main' &&
      (needs.e2e-fellspiral.result == 'failure' ||
       needs.e2e-videobrowser.result == 'failure' ||
       needs.e2e-audiobrowser.result == 'failure' ||
       needs.e2e-print.result == 'failure')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Note about Firebase Hosting rollback
        run: |
          echo "‚ö†Ô∏è  Firebase Hosting deployments don't support automatic rollback"
          echo "üìù To manually rollback, use: firebase hosting:rollback <site-id>"
          echo "üîç Sites: fellspiral, videobrowser-7696a, audiobrowser, print-dfb47"
          echo ""
          echo "Previous deployments are still available in Firebase Hosting history"

      - name: Create rollback issue
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'üö® Automatic Rollback: All Sites',
              body: `E2E tests failed after deployment to main branch.\n\nCommit: ${context.sha}\n\nWorkflow: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              labels: ['bug', 'deployment', 'rollback']
            })

  # ==================== Merge Check (Required Status Check) ====================
  merge-check:
    name: Merge Check - All Tests Passed
    runs-on: ubuntu-latest
    needs:
      [
        test-firebase-fellspiral,
        test-firebase-videobrowser,
        test-firebase-audiobrowser,
        test-firebase-print,
        test-go-fullstack-printsync,
        test-go-tui-tmux-tui,
        test-go-packages-filesync,
        deploy-firestore-rules,
        deploy-fellspiral,
        deploy-videobrowser,
        deploy-audiobrowser,
        deploy-print,
        e2e-fellspiral,
        e2e-videobrowser,
        e2e-audiobrowser,
        e2e-print,
      ]
    if: always()

    steps:
      - name: Check all jobs succeeded
        uses: actions/github-script@v7
        with:
          script: |
            const testJobs = [
              'test-firebase-fellspiral', 'test-firebase-videobrowser',
              'test-firebase-audiobrowser', 'test-firebase-print',
              'test-go-fullstack-printsync', 'test-go-tui-tmux-tui',
              'test-go-packages-filesync'
            ];
            const deployJobs = [
              'deploy-fellspiral', 'deploy-videobrowser',
              'deploy-audiobrowser', 'deploy-print',
              'deploy-firestore-rules'
            ];
            const e2eJobs = [
              'e2e-fellspiral', 'e2e-videobrowser',
              'e2e-audiobrowser', 'e2e-print'
            ];

            const needs = ${{ toJson(needs) }};
            let failed = false;

            // Test jobs can be skipped (if app doesn't exist)
            for (const job of testJobs) {
              const result = needs[job]?.result;
              if (result !== 'success' && result !== 'skipped') {
                console.log(`‚ùå ${job} failed with result: ${result}`);
                failed = true;
              }
            }

            // Deploy/E2E jobs should NEVER skip
            for (const job of [...deployJobs, ...e2eJobs]) {
              const result = needs[job]?.result;
              if (result === 'skipped') {
                console.log(`‚ùå CRITICAL: ${job} was skipped (workflow bug)`);
                failed = true;
              } else if (result !== 'success') {
                console.log(`‚ùå ${job} failed with result: ${result}`);
                failed = true;
              }
            }

            if (failed) {
              core.setFailed('Required jobs did not pass');
            } else {
              console.log('‚úÖ All required jobs succeeded');
            }
