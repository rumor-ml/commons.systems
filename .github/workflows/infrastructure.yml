name: Infrastructure as Code

# Manages GCP infrastructure via Terraform
on:
  push:
    branches:
      - main
      - claude/refactor-setup-scripts-017YWtTPSj64Wpnngb9YYWYW
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform action'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy

env:
  TF_VERSION: '1.6.0'
  WORKING_DIR: infrastructure/terraform

permissions:
  contents: write  # Required for creating commit comments
  pull-requests: write
  id-token: write  # Required for Workload Identity Federation

jobs:
  check:
    name: Branch Check
    runs-on: ubuntu-latest
    steps:
      - name: Verify branch or manual trigger
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]] || \
             [[ "${{ github.ref }}" == "refs/heads/claude/refactor-setup-scripts-017YWtTPSj64Wpnngb9YYWYW" ]] || \
             [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "âœ… Running on allowed branch or manual trigger"
          else
            echo "âŠ˜ Skipping - not on allowed branch"
          fi

  terraform:
    name: Terraform
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: check
    if: |
      github.ref == 'refs/heads/main' ||
      github.ref == 'refs/heads/claude/refactor-setup-scripts-017YWtTPSj64Wpnngb9YYWYW' ||
      github.event_name == 'workflow_dispatch'

    defaults:
      run:
        working-directory: ${{ env.WORKING_DIR }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Nix
        uses: cachix/install-nix-action@v25
        with:
          nix_path: nixpkgs=channel:nixos-unstable
          extra_nix_config: |
            experimental-features = nix-command flakes
            accept-flake-config = true

      - name: Setup Nix cache
        uses: cachix/cachix-action@v14
        continue-on-error: true
        with:
          name: fellspiral
          authToken: '${{ secrets.CACHIX_AUTH_TOKEN }}'
          skipPush: true

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}
          token_format: 'access_token'

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Create Terraform state bucket
        run: |
          nix develop .#ci --command bash -c "
            # Create the state bucket if it doesn't exist
            if ! gcloud storage buckets describe gs://fellspiral-terraform-state --project=${{ secrets.GCP_PROJECT_ID }} &>/dev/null; then
              echo 'Creating Terraform state bucket...'
              gcloud storage buckets create gs://fellspiral-terraform-state \
                --project=${{ secrets.GCP_PROJECT_ID }} \
                --location=us-central1 \
                --uniform-bucket-level-access

              # Enable versioning for state file protection
              gcloud storage buckets update gs://fellspiral-terraform-state \
                --versioning

              echo 'State bucket created successfully with versioning enabled'
            else
              echo 'State bucket already exists'
            fi

            # Grant service account access to state bucket
            echo 'Granting service account access to state bucket...'
            gcloud storage buckets add-iam-policy-binding gs://fellspiral-terraform-state \
              --member='serviceAccount:${{ secrets.GCP_SERVICE_ACCOUNT }}' \
              --role='roles/storage.objectAdmin' \
              --quiet || echo 'Permission already granted or failed (will retry)'

            # Grant service account permission to impersonate itself (needed for Workload Identity)
            echo 'Granting service account token creator role to itself...'
            gcloud iam service-accounts add-iam-policy-binding '${{ secrets.GCP_SERVICE_ACCOUNT }}' \
              --member='serviceAccount:${{ secrets.GCP_SERVICE_ACCOUNT }}' \
              --role='roles/iam.serviceAccountTokenCreator' \
              --quiet || echo 'Permission already granted or failed (will retry)'
          "

      - name: Load Nix environment
        run: nix develop .#ci --command bash -c "echo 'Nix environment loaded with gcloud and terraform'"

      - name: Create terraform.tfvars
        run: |
          cat > terraform.tfvars <<EOF
          project_id  = "${{ secrets.GCP_PROJECT_ID }}"
          region      = "us-central1"
          environment = "production"
          EOF

      - name: Terraform Format Check
        id: fmt
        run: nix develop .#ci --command terraform fmt -check -recursive
        continue-on-error: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"

      - name: Terraform Init
        id: init
        run: |
          # Debug: Check if bucket is accessible
          echo "Checking if state bucket is accessible..."
          gcloud storage buckets describe gs://fellspiral-terraform-state --project=${{ secrets.GCP_PROJECT_ID }} || echo "Bucket not accessible"

          # Debug: Show current GCP project
          echo "Current GCP project: $(gcloud config get-value project)"

          # Debug: Check authentication
          echo "Testing GCP authentication..."
          gcloud auth list

          # Debug: Try listing bucket contents
          echo "Attempting to access state bucket..."
          gsutil ls gs://fellspiral-terraform-state/ || echo "Cannot list bucket contents"

          # Initialize Terraform (GCS backend uses Application Default Credentials)
          terraform init -reconfigure

      - name: Import existing resources if needed
        id: import
        continue-on-error: true
        run: |
          bash -c "
            # Check if state is empty (no resources)
            RESOURCE_COUNT=\$(terraform state list 2>/dev/null | wc -l)

            if [ \$RESOURCE_COUNT -eq 0 ]; then
              echo 'ðŸ“¦ State is empty, checking for existing resources to import...'
              PROJECT_ID='${{ secrets.GCP_PROJECT_ID }}'

              # Import storage buckets if they exist
              if gcloud storage buckets describe gs://\${PROJECT_ID}-fellspiral-site &>/dev/null; then
                echo 'Importing site bucket...'
                terraform import google_storage_bucket.site_bucket \${PROJECT_ID}-fellspiral-site || true
              fi

              if gcloud storage buckets describe gs://\${PROJECT_ID}-fellspiral-site-backup &>/dev/null; then
                echo 'Importing backup bucket...'
                terraform import google_storage_bucket.backup_bucket \${PROJECT_ID}-fellspiral-site-backup || true
              fi

              # Import IP address if it exists
              if gcloud compute addresses describe fellspiral-site-ip --global --project=\${PROJECT_ID} &>/dev/null; then
                echo 'Importing static IP...'
                terraform import google_compute_global_address.site_ip projects/\${PROJECT_ID}/global/addresses/fellspiral-site-ip || true
              fi

              # Note: Service account is now a data source (github-actions-terraform),
              # not a resource, so no import needed

              # Import other resources
              terraform import google_compute_backend_bucket.site_backend fellspiral-backend 2>/dev/null || true
              terraform import google_compute_url_map.site_url_map fellspiral-url-map 2>/dev/null || true
              terraform import google_compute_target_http_proxy.site_http_proxy fellspiral-http-proxy 2>/dev/null || true
              terraform import google_compute_global_forwarding_rule.site_http fellspiral-http-forwarding-rule 2>/dev/null || true

              # Import IAM bindings
              SA_EMAIL=\"github-actions-terraform@\${PROJECT_ID}.iam.gserviceaccount.com\"
              terraform import google_storage_bucket_iam_member.public_read \"\${PROJECT_ID}-fellspiral-site roles/storage.objectViewer allUsers\" 2>/dev/null || true
              terraform import google_project_iam_member.github_actions_storage \"\${PROJECT_ID} roles/storage.admin serviceAccount:\${SA_EMAIL}\" 2>/dev/null || true
              terraform import google_project_iam_member.github_actions_compute \"\${PROJECT_ID} roles/compute.loadBalancerAdmin serviceAccount:\${SA_EMAIL}\" 2>/dev/null || true
              terraform import google_project_iam_member.github_actions_cloud_run \"\${PROJECT_ID} roles/run.admin serviceAccount:\${SA_EMAIL}\" 2>/dev/null || true
              terraform import google_project_iam_member.github_actions_artifact_registry \"\${PROJECT_ID} roles/artifactregistry.repoAdmin serviceAccount:\${SA_EMAIL}\" 2>/dev/null || true
              terraform import google_project_iam_member.github_actions_service_account_user \"\${PROJECT_ID} roles/iam.serviceAccountUser serviceAccount:\${SA_EMAIL}\" 2>/dev/null || true

              echo 'âœ… Import completed'
            else
              echo 'âœ… State already contains \$RESOURCE_COUNT resources, skipping import'
            fi
          "

      - name: Terraform Validate
        id: validate
        run: terraform validate -no-color

      - name: Terraform Plan
        id: plan
        run: terraform plan -no-color -out=tfplan
        continue-on-error: false

      - name: Save plan output
        id: plan-output
        run: |
          terraform show -no-color tfplan > plan.txt
          # Truncate if too long for PR comment
          if [ $(wc -l < plan.txt) -gt 100 ]; then
            head -n 100 plan.txt > plan_truncated.txt
            echo "... (output truncated)" >> plan_truncated.txt
            mv plan_truncated.txt plan.txt
          fi
          {
            echo 'plan<<EOF'
            cat plan.txt
            echo EOF
          } >> "$GITHUB_OUTPUT"

      - name: Terraform Apply
        if: |
          ((github.ref == 'refs/heads/main' || github.ref == 'refs/heads/claude/refactor-setup-scripts-017YWtTPSj64Wpnngb9YYWYW') && github.event_name == 'push') ||
          (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        run: terraform apply -auto-approve tfplan

      - name: Terraform Destroy
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
        run: terraform destroy -auto-approve

      - name: Get Infrastructure Outputs
        if: |
          ((github.ref == 'refs/heads/main' || github.ref == 'refs/heads/claude/refactor-setup-scripts-017YWtTPSj64Wpnngb9YYWYW') && github.event_name == 'push') ||
          (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        id: outputs
        run: |
          echo "bucket_name=$(terraform output -raw bucket_name)" >> $GITHUB_OUTPUT
          echo "site_ip=$(terraform output -raw site_ip)" >> $GITHUB_OUTPUT
          echo "site_url=$(terraform output -raw site_url)" >> $GITHUB_OUTPUT
          echo "sa_email=$(terraform output -raw deployment_service_account_email)" >> $GITHUB_OUTPUT

      - name: Post results
        if: |
          ((github.ref == 'refs/heads/main' || github.ref == 'refs/heads/claude/refactor-setup-scripts-017YWtTPSj64Wpnngb9YYWYW') && github.event_name == 'push') ||
          (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        uses: actions/github-script@v7
        with:
          script: |
            const output = `## Infrastructure Updated! ðŸš€

            **Infrastructure Details:**
            - Bucket: \`${{ steps.outputs.outputs.bucket_name }}\`
            - Static IP: \`${{ steps.outputs.outputs.site_ip }}\`
            - Site URL: ${{ steps.outputs.outputs.site_url }}
            - Service Account: \`${{ steps.outputs.outputs.sa_email }}\`

            **Next deployment to main will use this infrastructure automatically.**

            **Cost:** ~$0.13/month for typical traffic

            ---
            *Infrastructure managed via Terraform â€¢ Keyless auth via Workload Identity*`;

            github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: output
            });

      - name: Summary
        if: |
          ((github.ref == 'refs/heads/main' || github.ref == 'refs/heads/claude/refactor-setup-scripts-017YWtTPSj64Wpnngb9YYWYW') && github.event_name == 'push') ||
          (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        run: |
          echo "### Infrastructure Updated! âœ…" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Bucket:** ${{ steps.outputs.outputs.bucket_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Static IP:** ${{ steps.outputs.outputs.site_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "**Site URL:** ${{ steps.outputs.outputs.site_url }}" >> $GITHUB_STEP_SUMMARY
          echo "**Service Account:** ${{ steps.outputs.outputs.sa_email }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Infrastructure managed automatically via Terraform" >> $GITHUB_STEP_SUMMARY
