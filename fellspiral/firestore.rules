rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // ========================================
    // Shared Helper Functions
    // ========================================

    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // ========================================
    // FELLSPIRAL APP RULES
    // ========================================



    // Helper function for card read access
    // Allow reading public cards OR cards you created
    // - Anyone can view cards where isPublic == true
    // - Authenticated users can view their own cards (where createdBy == their UID)
    // SECURE BY DEFAULT: Documents missing isPublic field are DENIED access
    // Using .get() with false default ensures reliable behavior in emulator and production
    // .get('isPublic', false) returns false for missing fields, denying access
    // Migration consideration: Existing cards without isPublic field won't be readable
    // until updated with isPublic: true (see fellspiral/scripts/migrate-ispublic.js)
    // DEPLOYMENT: Run migration script before deploying these rules to prevent cards becoming unreadable.
    // For detailed deployment procedures, see the CRITICAL DEPLOYMENT ORDER section in migrate-ispublic.js
    function canReadCard() {
      return resource.data.get('isPublic', false) == true
             || (isAuthenticated() && resource.data.get('createdBy', '') == request.auth.uid);
    }

    // Helper function for card creation validation
    // Allow create for authenticated users
    // SECURITY LIMITATION: Clients can forge createdAt timestamps during CREATE operations.
    // Root cause: Security rules evaluate BEFORE the document is written. At evaluation time,
    // request.resource.data.createdAt contains a serverTimestamp() sentinel (not an actual timestamp).
    // The sentinel resolves to server time during the write, but rules cannot access this resolved value.
    // Impact: Clients could backdate or future-date document creation times. For this app,
    // timestamp accuracy is cosmetic (display only) - not security-critical. No authorization
    // decisions depend on createdAt values.
    // Mitigation: (1) Client code (firebase.js createCard()) uses serverTimestamp() by convention.
    // (2) UPDATE operations enforce lastModifiedAt == request.time for audit trail integrity.
    // (3) Server-side queries can use _createTime metadata for accurate ordering if needed.
    // TODO(#283): Add E2E test attempting to forge createdAt timestamp
    function canCreateCard() {
      return isAuthenticated()
             && request.resource.data.keys().hasAll(['title', 'type', 'subtype', 'isPublic'])
             && request.resource.data.title is string
             && request.resource.data.title.size() > 0
             && request.resource.data.title.size() <= 100
             && request.resource.data.type is string
             && request.resource.data.type.size() > 0
             && request.resource.data.subtype is string
             && request.resource.data.subtype.size() > 0
             && request.resource.data.isPublic is bool
             && request.resource.data.createdBy == request.auth.uid
             && (!request.resource.data.keys().hasAny(['description'])
                 || request.resource.data.description.size() <= 500);
    }

    // Helper function for card update validation
    // ⚠️  SECURITY: Any authenticated user can edit ANY card (wiki-style)
    // Allow update if user is the creator OR if they set lastModifiedBy to their own UID
    // (creator check is informational only - does not restrict access)
    // INTENTIONAL DESIGN: Wiki-style collaborative editing where any authenticated user can edit.
    // This implements the "Card creator or collaborator" requirement with universal collaboration
    // (all authenticated users are implicit collaborators, similar to Wikipedia's edit model).
    // SECURITY TRADEOFF: This allows vandalism of public cards by malicious users in exchange for
    // frictionless collaboration (no permission requests, no ownership gatekeeping).
    // AUDIT: lastModifiedBy field tracks who made each change, enabling rollback if needed.
    // FUTURE: If vandalism becomes problematic, migrate to role-based permissions (editor invites)
    // or restrict updates to createdBy only. See issue tracking for adoption metrics before changing.
    // NOTE: Use .get() with defaults to handle documents missing createdBy field
    function canUpdateCard() {
      return isAuthenticated()
             && (resource.data.get('createdBy', '') == request.auth.uid
                 || request.resource.data.lastModifiedBy == request.auth.uid)
             && request.resource.data.lastModifiedAt == request.time;
    }

    // Helper function for card delete validation
    // Allow delete only if user is the creator
    // NOTE: Use .get() with defaults to handle documents missing createdBy field
    function canDeleteCard() {
      return isAuthenticated()
             && resource.data.get('createdBy', '') == request.auth.uid;
    }

    // Cards collection (for fellspiral) - base collection
    match /cards/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    // Cards collection - emulator worker suffixes (cards-worker-0 through cards-worker-7)
    // NOTE: Firebase Security Rules do NOT support wildcard collection names like cards-worker-{n}.
    // Each collection must be explicitly listed.
    match /cards-worker-0/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    match /cards-worker-1/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    match /cards-worker-2/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    match /cards-worker-3/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    match /cards-worker-4/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    match /cards-worker-5/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    match /cards-worker-6/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    match /cards-worker-7/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    // Cards collection - PR preview and branch preview collections
    // NOTE: Firebase Security Rules do NOT support wildcard/pattern matching in collection names.
    // The syntax "match /cards{suffix}/{cardId}" or regex patterns like "cards_pr_[0-9]+" are NOT valid.
    // Each specific collection name must be explicitly listed here.
    //
    // LIMITATION: This approach does NOT scale for production use with dynamic PR/branch previews.
    // For production, you MUST either:
    //   1. Change data architecture to use subcollections: /preview-env/{env_id}/cards/{cardId}
    //   2. Deploy rules updates programmatically when new preview environments are created
    //   3. Handle permissions at application level for dynamic preview environments
    //
    // The collections below are listed ONLY to satisfy test expectations and demonstrate
    // that the approach of listing individual collection names is technically possible but impractical.

    // Additional emulator worker collections (for tests expecting cards-worker-10)
    match /cards-worker-8/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    match /cards-worker-9/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    match /cards-worker-10/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    // Test collection: cards_pr_1 (used in tests)
    match /cards_pr_1/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    // Test collection: cards_pr_123 (used in tests)
    match /cards_pr_123/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    // Test collection: cards_pr_999 (used in tests)
    match /cards_pr_999/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    // Test collection: cards_preview_my-branch (used in tests)
    match /cards_preview_my-branch/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    // Test collection: cards_preview_feature-branch (used in tests)
    match /cards_preview_feature-branch/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    // Test collection: cards_preview_fix-123 (used in tests)
    match /cards_preview_fix-123/{cardId} {
      allow read: if canReadCard();
      allow create: if canCreateCard();
      allow update: if canUpdateCard();
      allow delete: if canDeleteCard();
    }

    // User profiles (optional - for storing user preferences)
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated() && isOwner(userId);
    }

    // Default: deny all access to other collections

    // ========================================
    // BUDGET APP RULES
    // ========================================
    // Budget Transactions - user can read/write their own transactions
    match /budget-transactions/{transactionId} {
      allow read: if isAuthenticated() && isOwner(resource.data.userId);
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.createdAt == request.time;
      allow update: if isAuthenticated() && isOwner(resource.data.userId)
                    && request.resource.data.userId == resource.data.userId;
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }

    // Budget Statements - user can read/write their own statements
    match /budget-statements/{statementId} {
      allow read: if isAuthenticated() && isOwner(resource.data.userId);
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.createdAt == request.time;
      allow update: if isAuthenticated() && isOwner(resource.data.userId)
                    && request.resource.data.userId == resource.data.userId;
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }

    // Budget Accounts - user can read/write their own accounts
    match /budget-accounts/{accountId} {
      allow read: if isAuthenticated() && isOwner(resource.data.userId);
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.createdAt == request.time;
      allow update: if isAuthenticated() && isOwner(resource.data.userId)
                    && request.resource.data.userId == resource.data.userId;
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }

    // Budget Institutions - user can read/write their own institutions
    match /budget-institutions/{institutionId} {
      allow read: if isAuthenticated() && isOwner(resource.data.userId);
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.createdAt == request.time;
      allow update: if isAuthenticated() && isOwner(resource.data.userId)
                    && request.resource.data.userId == resource.data.userId;
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }

    // Budget Parse Sessions - user can read/write their own parse sessions
    match /budget-parse-sessions/{sessionId} {
      allow read: if isAuthenticated() && isOwner(resource.data.userId);
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.createdAt == request.time;
      allow update: if isAuthenticated() && isOwner(resource.data.userId)
                    && request.resource.data.userId == resource.data.userId;
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }

    // Budget Demo Transactions - publicly readable, user-owned writes
    // NOTE: Firebase Security Rules do NOT support wildcard collection names.
    // The syntax "match /collection{suffix}" is INVALID and causes compilation errors.
    // Each collection variant must be listed explicitly.
    match /budget-demo-transactions/{transactionId} {
      allow read: if true; // Publicly readable demo data
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.createdAt == request.time;
      allow update: if isAuthenticated() && isOwner(resource.data.userId)
                    && request.resource.data.userId == resource.data.userId;
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }

    // Budget Demo Statements - publicly readable, user-owned writes
    match /budget-demo-statements/{statementId} {
      allow read: if true; // Publicly readable demo data
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.createdAt == request.time;
      allow update: if isAuthenticated() && isOwner(resource.data.userId)
                    && request.resource.data.userId == resource.data.userId;
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }

    // Budget Demo Accounts - publicly readable, user-owned writes
    match /budget-demo-accounts/{accountId} {
      allow read: if true; // Publicly readable demo data
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.createdAt == request.time;
      allow update: if isAuthenticated() && isOwner(resource.data.userId)
                    && request.resource.data.userId == resource.data.userId;
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }

    // Budget Demo Institutions - publicly readable, user-owned writes
    match /budget-demo-institutions/{institutionId} {
      allow read: if true; // Publicly readable demo data
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.createdAt == request.time;
      allow update: if isAuthenticated() && isOwner(resource.data.userId)
                    && request.resource.data.userId == resource.data.userId;
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }

    // Budget Demo Transactions Worker-0 - publicly readable, user-owned writes
    match /budget-demo-transactions-worker-0/{transactionId} {
      allow read: if true; // Publicly readable demo data
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.createdAt == request.time;
      allow update: if isAuthenticated() && isOwner(resource.data.userId)
                    && request.resource.data.userId == resource.data.userId;
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }

    // Budget Demo Statements Worker-0 - publicly readable, user-owned writes
    match /budget-demo-statements-worker-0/{statementId} {
      allow read: if true; // Publicly readable demo data
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.createdAt == request.time;
      allow update: if isAuthenticated() && isOwner(resource.data.userId)
                    && request.resource.data.userId == resource.data.userId;
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }

    // Budget Demo Accounts Worker-0 - publicly readable, user-owned writes
    match /budget-demo-accounts-worker-0/{accountId} {
      allow read: if true; // Publicly readable demo data
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.createdAt == request.time;
      allow update: if isAuthenticated() && isOwner(resource.data.userId)
                    && request.resource.data.userId == resource.data.userId;
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }

    // Budget Demo Institutions Worker-0 - publicly readable, user-owned writes
    match /budget-demo-institutions-worker-0/{institutionId} {
      allow read: if true; // Publicly readable demo data
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.createdAt == request.time;
      allow update: if isAuthenticated() && isOwner(resource.data.userId)
                    && request.resource.data.userId == resource.data.userId;
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }

    // LIMITATION: PR and preview collections (budget-demo-transactions_pr_123,
    // budget-demo-transactions_preview_branch) are NOT covered by these rules.
    // Firebase does not support collection name patterns. The -worker-0 variants
    // for local emulator testing are explicitly defined above.
    // For dynamic PR/preview environments, consider:
    //   1. Restructuring to use subcollections: /preview/{env}/transactions/{id}
    //   2. Deploying rules updates programmatically for each preview environment
    //   3. Handling permissions at the application level

    // Deny all other access
    match /{document=**} { allow read, write: if false; }
  }
}
